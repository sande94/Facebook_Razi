You're given a SystemVerilog class for a byte-addressable memory model, and you're asked to implement a method called move() 
that copies data from one region of memory to another within the same array.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
class byte_memory_model #(int DEPTH = 1024);
  localparam ADDR_W = $clog2(DEPTH);
  bit [7:0] mem[DEPTH];

  // Write a byte to memory
  function void write(bit [ADDR_W-1:0] address, bit [7:0] data);
    assert(address < DEPTH) else $fatal("Write address out of bounds");
    mem[address] = data;
  endfunction

  // Read a byte from memory
  function bit [7:0] read(bit [ADDR_W-1:0] address);
    assert(address < DEPTH) else $fatal("Read address out of bounds");
    return mem[address];
  endfunction

  // Move 'size' bytes from source_address to dest_address
  function void move(
    bit [ADDR_W-1:0] source_address,
    bit [ADDR_W-1:0] dest_address,
    bit [ADDR_W-1:0] size
  );
    // Bounds check
    assert(source_address + size <= DEPTH) else $fatal("Source out of bounds");
    assert(dest_address + size <= DEPTH) else $fatal("Destination out of bounds");

    // Overlapping region: backward copy
    if (source_address < dest_address && (source_address + size) > dest_address) begin
      for (int i = size - 1; i >= 0; i--) begin
        mem[dest_address + i] = mem[source_address + i];
      end
    end else begin
      // Forward copy
      for (int i = 0; i < size; i++) begin
        mem[dest_address + i] = mem[source_address + i];
      end
    end
  endfunction
endclass



If the destination overlaps the source and starts after, you copy backwards to prevent overwriting the source data.

If there's no overlap or dest is before source, you can safely copy forwards.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
module test_memory_move;
  byte_memory_model #(64) mem;

  initial begin
    mem = new();

    // Step 1: Write values 1 to 10 at address 0 to 9
    for (int i = 0; i < 10; i++) begin
      mem.write(i, i + 1);
    end

    // Step 2: Move 10 bytes from address 0 to address 20
    mem.move(0, 20, 10);

    // Step 3: Print and verify values at new location
    $display("After move from 0 to 20:");
    for (int i = 0; i < 10; i++) begin
      bit [7:0] val = mem.read(20 + i);
      $display("mem[20 + %0d] = %0d", i, val);
      assert(val == i + 1) else $fatal("Move failed at byte %0d", i);
    end

    $display("âœ… Move function passed all checks.");
    $finish;
  end
endmodule


