You're given a SystemVerilog class for a byte-addressable memory model, and you're asked to implement a method called move() 
that copies data from one region of memory to another within the same array.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
function void byte_memory_model::move(
  bit [ADDR_W-1:0] source_address,
  bit [ADDR_W-1:0] dest_address,
  bit [ADDR_W-1:0] size
);
  // Check for out-of-bounds access
  assert(source_address + size <= DEPTH)
    else $fatal("Source range out of bounds: source_address=%0d, size=%0d", source_address, size);

  assert(dest_address + size <= DEPTH)
    else $fatal("Destination range out of bounds: dest_address=%0d, size=%0d", dest_address, size);

  // Handle overlapping case safely
  if (source_address < dest_address && (source_address + size) > dest_address) begin
    // Overlapping and dest is after source, copy backwards
    for (int i = size - 1; i >= 0; i--) begin
      mem[dest_address + i] = mem[source_address + i];
    end
  end else begin
    // No overlap or dest is before source, safe to copy forwards
    for (int i = 0; i < size; i++) begin
      mem[dest_address + i] = mem[source_address + i];
    end
  end
endfunction


If the destination overlaps the source and starts after, you copy backwards to prevent overwriting the source data.

If there's no overlap or dest is before source, you can safely copy forwards.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
class byte_memory_model #(int DEPTH = 1024);
  localparam ADDR_W = $clog2(DEPTH);
  bit [7:0] mem[DEPTH];

  // Write a byte to memory
  function void write(bit [ADDR_W-1:0] address, bit [7:0] data);
    assert(address < DEPTH) else $fatal("Write address out of bounds");
    mem[address] = data;
  endfunction

  // Read a byte from memory
  function bit [7:0] read(bit [ADDR_W-1:0] address);
    assert(address < DEPTH) else $fatal("Read address out of bounds");
    return mem[address];
  endfunction

  // Move 'size' bytes from source_address to dest_address
  function void move(
    bit [ADDR_W-1:0] source_address,
    bit [ADDR_W-1:0] dest_address,
    bit [ADDR_W-1:0] size
  );
    // Bounds check
    assert(source_address + size <= DEPTH) else $fatal("Source out of bounds");
    assert(dest_address + size <= DEPTH) else $fatal("Destination out of bounds");

    // Overlapping region: backward copy
    if (source_address < dest_address && (source_address + size) > dest_address) begin
      for (int i = size - 1; i >= 0; i--) begin
        mem[dest_address + i] = mem[source_address + i];
      end
    end else begin
      // Forward copy
      for (int i = 0; i < size; i++) begin
        mem[dest_address + i] = mem[source_address + i];
      end
    end
  endfunction
endclass

